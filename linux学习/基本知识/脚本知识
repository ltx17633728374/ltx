脚本起始:   (让脚本开机自启/etc/rc.local,给软链接加权限chmod +x /etc/rc.d/rc.local)
	#!:指定翻译器
	#:注释文本
	>：只收集前面命令的正确输出信息，写入文本文件中(>>追加重定向)
	2>：只收集前面命令的错误输出信息，写入文本文件中
	&>：收集前面命令的正确与错误输出信息，写入文本文件中
	>&2 : 直接把前面的命令输出结果变成错误输出,用exit命令返回一个非零的值

	< :不从键盘读取数据,从后面的文件中读取
	黑洞设备：/dev/null  专用于收集无用的信息
	read :     #产生交互,记录用户在键盘上的输入,将记录的信息赋值给变量
   		 -p ：屏幕的提示信息
     	 例:read  -p  '请输入您要创建的用户:'     abc
	添加变量:$ (set查看全部变量)
		环境变量:USER=永远储存当前系统登陆的用户名PATH：存储命令程序的路径,(env可以查看所有环境变量)
			$PS1 #默认一级提示
			$PS2 #默认二级提示				
		位置变量:由系统定义完成,在执行脚本时,提供的命令行参数,表示为 $n,n为序号
		预定义变量: 	$#   已加载的位置变量的个数(计算用户输入位置变量的个数)
				$*   所有位置变量的值
     				$?   程序退出后的状态值,0表示正常,其他值异常
		自定义变量:export 变量名     #把变量定义为全局变量

stty -echo #隐藏输入信息
	检查文档状态
		-e:文档存在为真
		-d:文档存在,且为目录才为真
		-f:文档存在,且为文件才为真
		-r:文档存在,且具备读取权限才为真
		-w:文档存在,且具备写入权限才为真
		-x:文档存在,且具备执行权限才为真
	比较整数大小
   		-gt：大于
   		-ge：大于等于
   		-eq：等于
   		-ne：不等于
   		-lt：小于
   		-le：小于等于
	字符串比对
   		==:两个字符串相等为真
   		!=:两个字符串不相等为真
	反撇号和$():将命令的输出，作为另一个命令的参数，参与下一个命令的运行

if格式:
	if  [条件测试];then
	   命令序列xx
	else
	   命令序列yy
	fi
for格式:
	for 变量名 in 值列表    #值列表可以用造数函数:{起始数值..结束数值}
    	 do
             命令序列
    	 done
while格式:
	while [条件测试]
	do
	   命令序列
	done
case分支:
	case 变量 in
	模式1)
	   命令序列1;;
	模式2)
	   命令序列2;;
	...
	*)
	   默认命令序列
	esac
函数:
	函数名(){
		代码
	}
   调用函数:函数名 &    #把函数放入后台
中断及控制:
	在循环中:  [条件] && continue 单独跳过条件中的选项
		   [条件] && break 遇到条件中的选项时中断循环
		   [条件] && exit 遇到条件中的选项时退出脚本 	   

	
计算器:
	expr $a + / - $b
	expr $a \* / '*' $b
	expr $a % $b 取余数
	echo $[a+b]/((a+b))
	echo $[a*b]/((a*b))       
	let x++	#x=x+1
	let x--	#x=x-1
	let x+=7	#x=x+7
	let x-=7	#x=x-7
	let x*=7	#x=x*7
	let x/=7	#x=x/7
	let x%=7	#x=x%7
   bc计算器:
	scale=2   #小数点后两位

条件测试:
	检查文档状态
		-e:文档存在为真
		-d:文档存在,且为目录才为真
		-f:文档存在,且为文件才为真
		-r:文档存在,且具备读取权限才为真
		-w:文档存在,且具备写入权限才为真
		-x:文档存在,且具备执行权限才为真
		-b:设备
	比较整数大小
   		-gt：大于
   		-ge：大于等于
   		-eq：等于
   		-ne：不等于
   		-lt：小于
   		-le：小于等于
	字符串比对
   		==:两个字符串相等为真
   		!=:两个字符串不相等为真
	反撇号和$():将命令的输出，作为另一个命令的参数，参与下一个命令的运行

	一行执行多命令
		A && B   	#A执行成功才执行B
		A || B	#A执行失败才执行B	
		A ; B		#执行A之后执行B
		A && B || C	#A或B执行失败执行C
	判断变量:
	[ -z $A ] && echo y || echo n  #变量为空返回值为n

字符串截取:
	${#变量名}       #查看变量长度
	${变量名:截取起始位置:截取长度}       #截取变量输出的字符串,起始位置为0
	expr substr $变量 截取起始位置 截取长度    # 截取变量输出的字符串,起始位置为1
	echo $变量名 | cut -b 起始位置-结束位置(或者3,5,7,表示分别截取3,5,7)    # 截取变量输出的字符串,起始值为1
字符串替换:
	${变量名/old/new}   #替换最近的一个old
	${变量名//old/new}   #替换所有old
	${变量名##*:}    #删除所有"*:" 从头开始删除
	${变量名%%:*}     #删除所有":*"  从尾开始删
取值:
	${变量名:-100}   #取值变量,如果变量不存在则赋值给它为100
非交互工具:
	yum - y install expect
	expect << EOF
	spawn ssh -o StrictHostKeyChecking=no 192.168.4.$i
	expect "password" {send "readhat \n"}   #匹配到password时候输入redhat+回车
	expect "#" {send "exit\r"}		   #匹配到#时输入exit+回车
	EOF

正则表达式:
	^匹配行首
	$匹配行尾
	[]匹配集合中的字符
	[^]对集合取反
	.匹配任意单个字符
	*匹配前一个字符(不可以单独使用)
	\{n,m\}匹配前一个字符n到m次
	\{n,\}匹配前一个字符n次
	\(\)保留
扩展正则:
	+最少匹配一次
	?最多匹配一次
	{n,m}匹配n到m次
	()保留
	|或者
	\b单次边界

sed工具:
	sed 选项 '条件指令' 文件
	-n(屏蔽默认输出,sed默认会输出全部内容)
	-r(让sed支持扩展正则)
	-i(sed直接改源文件)	
     sed的条件指令
	p:表示行数
		sed -n '3,5p' /etc/passwd    #打印3-5行
		sed -n '3p;5p' /etc/passwd   #打印3和5行
		sed -n '3,+10p' /etc/passwd   #打印第三行和后面的10行
		sed -n '1~2p' /etc/passwd     #打印奇数行
		sed -n '2~2p' /etc/passwd     #打印偶数行
		sed -n '/root/p'               #打印包含root的
	d:删除行
		sed -n 'xml/d' a.txt         #删除所有包含xml的行
		sed -n 'xml/!d' a.txt        #删除不包含xml的行
		sed -n '/^install/d' a.txt    #删除以install开头的行
		sed -n '$d' a.txt             #删除文件的最后一行
		sed -n '/^$/d' a.txt       	# 删除所有空行
	s:替换行
		sed -n 's/xml/XML/3'             #将第三行的xml换成XML
		sed -n 's/xml/XML/g'             #将所有xml都换成XML
		sed -n 's#/bin/bash#/sbin/sh#'    #把/bin/bash换成/sbin/sh
		sed -n '4,7s/^/#/'                #把4-7行加#
		sed -n 's/^#an/an/'              #去除以#an开头的#
		sed -r 's/.//2;s/.$//'           #删除每行第二个最后一个字符
		sed -r 's/^(.)(.*)(.)$/\3\2\1'   #把第一个字符和第三个字符调换
		sed -r 's/[0-9]//g;s/^()+//'     #删除所有数字,行首的空格
		sed -r 's/([A-Z])/[\1]/g         #把所有大写字母加括号,前面例子中,小括号表示复制,\表示粘贴
	i:在指定的行前面插入文本
	a:在指定的行后面追加文本
	c:替换指定的行
	综合格式   sed '2c XXX' ###把第二行换成XXX

awk工具:
	awk [] '条件{指令}' 文件名
	1基本操作:awk '{print $1,$3}' test.txt  #打印1,3列,默认以空格分割
	2指定分割符号 awk -F [:/] '{print $1,$10}' /etc/passwd  #打印以:或者/分割的第一列和第十列
   内置变量 $0表示全部文本,$1表示第一行,NR表示行号,NF表示行数
   awk处理时间:
	BEGIN{}:读取文件内容前执行,执行1次
	{}:读取每一行都处理一次
	END{}:文件读取结束后执行
            连用:awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd    #打印以bash结尾的个数
	   结合连用(/t可以制表):awk -F: 'BEGIN{print "USER\tUID\tHOME"} {print $1 "\t" $3 "\t" $6} END{print "Total",NR."lines."}' /etc/passwd
						打印标题				每行都打印想要的输出			打印最后一行,输出行数
    awk处理条件:
	'$1~/root/'    #第一列包含root
	'$7!~/nologin'   #最后一列不包含nologoin
	== ,!=不等于,>,<,>=,<=
    awk中的if:
	awk -F: '{if($7~/bash$/){i++}else{j++}}END{printi,j}' /etc/passwd     #打印结尾以bash结尾或者不是bash结尾的个数
    awk中的数组:
	数组可存储多个值,数组可以使用下标来标记自己的变量
	数组名[下标]=变量值(##下标可以用常量,但是要加"")
	for (变量in数组名){print 数组名[变量]} 
	awk 'BEGIN{a[0]=0;a[1]=11,;a[2]=22;for(i in a){print i,a[i]}}    #在数组中调用变量打印
		0 0
		1 11
		2 22     #数组a中有0,1,2,for循环调用三次,每次打印不同的数字
     awk处理完数据后,可以用 | sort -nr 来排序








